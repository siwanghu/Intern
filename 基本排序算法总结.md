# 基本排序算法总结（siwang.hu&nbsp;&nbsp;V1.0）  
> + 内部排序是数据记录在内存中进行排序，排序过程中不需要访问外存  
>  
> + 外部排序是数据量巨大，内存一次无法容纳所有的数据，排序过程中需要访问外存  
>  
> ![图片](./data/sort.png)  
>  
> **排序算法的稳定性是指排序前后若存在相同关键字的元素之间相对次序没有改变，则这个排序算法就是稳定的；否则，这个排序算法就是不稳定的**  
>  
## 冒泡排序  
> + 比较相邻的元素，如果第一个比第二个大，就交换相邻两个元素  
>  
> + 对每一对相邻元素做此步骤，直到最后一对相邻元素，一轮之后，最大的元素交换到最后  
>  
> + 以同样的方法重复上述两步（除了上轮最后一个元素不参与下一轮）  
>  
> **example**  
```
public void bubbleSort(int[] array){
    for(int i=0;i<array.length;i++){
        for(int j=1;j<array.length-i;j++){
            if(array[j-1]>array[j]){
                int temp=array[j];
                array[j]=array[j-1];
                array[j-1]=temp;
            }
        }
    }
}
```
## 选择排序  
> + 在未排序的序列中找到最小值，存放在排序序列起始位置  
>  
> + 从剩余为排序序列中找到最小值，添加到以排序序列后面  
>  
> + 重复以上，直到没有剩余未排序序列为止  
>  
> **example**
```
public void selectSort(int[] array){
    for(int i=0;i<array.length;i++){
        for(int j=i;j<array.length;j++){
            if(array[i]>array[j]){
                int temp=array[j];
                array[j]=array[i];
                array[i]=temp;
            }
        }
    }
}
```
## 插入排序  
> + 将无序序列中的第一个元素看成有序序列  
>  
> + 将有序序列后面的无序序列的每个元素插入到前面有序序列的合适位置  
>  
> + 重复上一步，直到将无序序列中的元素都插入到前面有序序列中的合适位置  
>  
> **example**  
```
public void insertSort(int[] array){
    for(int i=0;i<array.length;i++){
        for(int j=i;j>0;j--){
            if(array[j]<array[j-1]){
                int temp=array[j];
                array[j]=array[j-1];
                array[j-1]=temp;
            }
        }
    }
}
```