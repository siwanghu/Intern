# 基本排序算法总结（siwang.hu&nbsp;&nbsp;V1.0）  
> + 内部排序是数据记录在内存中进行排序，排序过程中不需要访问外存  
>  
> + 外部排序是数据量巨大，内存一次无法容纳所有的数据，排序过程中需要访问外存  
>  
> ![图片](./data/sort.png)  
>  
> **排序算法的稳定性是指排序前后若存在相同关键字的元素之间相对次序没有改变，则这个排序算法就是稳定的；否则，这个排序算法就是不稳定的**  
>  
## 冒泡排序  
> + 比较相邻的元素，如果第一个比第二个大，就交换相邻两个元素  
>  
> + 对每一对相邻元素做此步骤，直到最后一对相邻元素，一轮之后，最大的元素交换到最后  
>  
> + 以同样的方法重复上述两步（除了上轮最后一个元素不参与下一轮）  
>  
> **example**  
```
public void bubbleSort(int[] array){
    for(int i=0;i<array.length;i++){
        for(int j=1;j<array.length-i;j++){
            if(array[j-1]>array[j]){
                int temp=array[j];
                array[j]=array[j-1];
                array[j-1]=temp;
            }
        }
    }
}
```
## 选择排序  
> + 在未排序的序列中找到最小值，存放在排序序列起始位置  
>  
> + 从剩余为排序序列中找到最小值，添加到以排序序列后面  
>  
> + 重复以上，直到没有剩余未排序序列为止  
>  
> **example**  
```
public void selectSort(int[] array){
    for(int i=0;i<array.length;i++){
        for(int j=i;j<array.length;j++){
            if(array[i]>array[j]){
                int temp=array[j];
                array[j]=array[i];
                array[i]=temp;
            }
        }
    }
}
```
## 插入排序  
> + 将无序序列中的第一个元素看成有序序列  
>  
> + 将有序序列后面的无序序列的每个元素插入到前面有序序列的合适位置  
>  
> + 重复上一步，直到将无序序列中的元素都插入到前面有序序列中的合适位置  
>  
> + 插入排序有移位法与交换法，这里我们采用交换法实现  
>  
> **example**  
```
public void insertSort(int[] array){
    for(int i=0;i<array.length;i++){
        for(int j=i;j>0;j--){    
            if(array[j]<array[j-1]){     //交换法实现
                int temp=array[j];
                array[j]=array[j-1];
                array[j-1]=temp;
            }
        }
    }
}
```
## 希尔排序  
> + 选择一个增量序列t1，t2,...,tk，其中 ti > tj, tk = 1  
>  
> + 增量的选择是随意的，只要最后一个增量为1即可  
>  
> + 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m的子序列,分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度  
>  
> ![图片](./data/shellsort.PNG)  
>  
> **example**  
```
public void shellSort(int[] array){
    for(int grap=array.length/2;grap>0;grap/=2){
        for(int i=0;i<array.length;i+=grap){
            for(int j=i;j>0;j-=grap){
                if(array[j]<array[j-grap]){
                    int temp=array[j-grap];
                    array[j-grap]=array[j];
                    array[j]=temp;
                }
            }
        }
    }
}
```
## 归并排序  
> + 在排序前，建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间  
>  
> + 设定两个指针，最初位置分别为两个已经排序序列的起始位置  
>  
> + 比较两个指针所指向的元素，选择相对小的元素放入到临时数组，并移动指针到下一位置  
>  
> + 直到某一指针达到序列尾，将另一序列剩下的所有元素直接复制到合并序列尾  
>  
> + 递归执行序列合并操作  
>  
> ![图片](./data/merge.PNG)  
>  
> **example**  
```

```